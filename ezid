#! /bin/bash

# program at end of file. search #MAIN
function args_to_anvl() {
  local nv='^([^:]+)[ \t]*:[ \t]*(.*)$'
  local n
  local v

  declare -A update
  while [[ -n $1 ]]; do
	  case $1 in
	    -- ) shift; break;;
	    *)
        if [[ $1 =~ $nv ]]; then
          n=${BASH_REMATCH[1]};
          v="${BASH_REMATCH[2]}";
          update[$n]=$(decode "$v");
        else
          log rest $1
          err 1 "Bad Option:" $1
        fi
        shift;;
    esac
  done

  local inp
  if [[ ! -t 0 ]]; then
    inp=$(anvl -A)
    eval "declare -A inp_anvl=${inp#*=}"
  for n in ${!inp_anvl[@]}; do
    update[$n]=${inp_anvl[$n]};
  done
  fi

  local anvl=$(to_anvl "$(declare -p update)")
  echo "$anvl"
}

function to_anvl() {
  eval "declare -A anvl="${1#*=}
  for n in ${!anvl[@]}; do
    echo $(encode "$n"): $(encode "${anvl[$n]}")
  done
}

function anvl() {
  local opts=`getopt -o Ac:a: --long array,csv:,ark: -n 'ezid anvl' -- "$@"`

  if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi
  eval set -- "$opts"

  local array;
  local ark;
  while true; do
	  case $1 in
      -A | --array ) array=1; shift;;
      -a | --ark ) ark=$2; shift;;
      -c | --csv )
        IFS=':' read -r -a csv <<< "$2"
        shift 2;;
	    -- ) shift; break;;
	    *) shift; break;
    esac
  done

  declare -A anvl
  local cont='^[ \t]+(.*)';
  local nv='^([^:]+)[ \t]*:[ \t]*(.*)$'
  local n
  local v
  while IFS='' read -r line || [[ -n "$line" ]] ; do
    if [[ $line =~ ^# ]]; then
      true
    elif [[ $line =~ $cont ]]; then
      line=${BASH_REMATCH[1]}
      if [[ -n $n ]]; then
        v+=" $line";
      else
        err 1 'Bad continuation: $line'
      fi
    elif [[ $line =~ $nv ]]; then
      if [[ -n $n ]]; then
        anvl[$n]=$(decode "$v");
        n=''
      fi
      n=${BASH_REMATCH[1]};
      v="${BASH_REMATCH[2]}";
    else
      err 1 "unknown $line"
    fi
  done

  if [[ -n $n ]]; then
    anvl[$n]=$(decode "$v");
    n=''
  fi

  # Now print the output
  local row
  if [[ -n $array ]]; then
    declare -p anvl
  elif [[ -n $csv ]]; then
    anvl[ark]=$ark;    # Allow specification of bad ark
    local row
    local i
    for i in "${csv[@]}"; do
      row+=,$(to_csv "${anvl[$i]}")
    done
    echo ${row:1}
  fi
}

function login() {
    local opts=`getopt -o a --long auth: -n 'ezid login' -- "$@"`
    if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

    eval set -- "$opts"

    local auth=

    while true; do
	    case $1 in
        -a | --auth ) auth=$2; shift 2;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done
   _http --auth=${auth} https://ezid.cdlib.org/login
}

function mint() {
    local opts=`getopt -o p: --long proxy: -n 'ezid mint' -- "$@"`
    if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

    eval set -- "$opts"

    local proxy=

    while true; do
	    case $1 in
        --proxy ) proxy=$2; shift 2;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    local anvl=$(args_to_anvl "$@")
    local resp=$(_http --print=b POST https://ezid.cdlib.org/shoulder/${BASE[base]} Content-Type:text/plain <<<"$anvl")
    resp=$(anvl -A <<<$resp);
    eval "declare -A anvl="${resp#*=}
    if [[ -z ${anvl[success]} ]]; then
      err 1 "No success: $resp"
    fi
    ark=${anvl[success]}
    echo $ark
    if [[ -n $proxy ]]; then
      log update ${anvl[success]} _target:${proxy}${ark}
    fi
}

function update() {
  local opts=`getopt -o c:Av --long csv:,array,verify -n 'ezid update' -- "$@"`
  if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

  eval set -- "$opts"

  local csv
  local array
  local verify

  while true; do
	  case $1 in
      -c | --csv ) csv="--csv=$2"; shift 2;;
      -v | --verify) verify=1; shift ;;
      -A | --array ) array='--array'; shift ;;
	    -- ) shift; break;;
	    *) shift; break;
    esac
  done

  local ark_in=$1
  local ark=https://ezid.cdlib.org/id/$(fq $1)
  [[ $? != 0 ]] && err 1 '$1 is not a valid ark';
  shift
  log ARK $ark_in $ark

  local anvl=$(args_to_anvl "$@")



  local resp=$(_http --print=b POST $ark Content-Type:text/plain <<<"$anvl")
  local rarr=$(anvl -A <<<$resp);
  eval "declare -A anvl="${rarr#*=}
  if [[ -z ${anvl[success]} ]]; then
    err 1 "No success: $resp"
  fi
  local suc=${anvl[success]}
  if [[ -n $verify || -n $csv || -n $array ]]; then
    get $csv $array $ark_in
  fi
}

: <<=cut
=pod

=head1  NAME

  ezid - Get, Add and Update ARKS via the EZID api

=head1 USAGE

  ark [-S|--session=I<httpie session>] [-b|--base=I<base>] \
  [--who=I<who>] [--what=I<what>] [--when=I<when>] \
  [--status=I<reserved|public>]
	[-n|--dry-run] [-p|--print] \
	I<cmd> [cmd-options]

	where <cmd> = get|patch|put

=cut

: <<=cut

=pod

=head1 OPTIONS

=over 4

=item B<-S|--session=I<httpie_session>>

Set the HTTP session variable. This allows you to maintain multiple
authentication setups for your EZID, so that you can go back and forth between
users.

=item B<-s |--base=I<base>>
Set the base that you want to use.  The base is a combination of the scheme,NAAN, and shoulder
components of the identifier. The Default base is the EZID ark testing shoulder B<ark:/99999/fk4>.
This is a safe place to do your testing.

=item B<--who=I<who>>
Metadata, who

=item B<--what=I<what>>
Metadata, what

=item B<--when=I<when>>
Metadata, when

=item B<-n|--dry-run>
Show what you would do do not really do it

=item B<-p|--print>
Adjust httpie --print= argument

=back
=cut

function main.cmd () {
    cmd=$1
    shift;
    case $cmd in
      put )
        create "$@"
        ;;
      post )
        mint "$@"
        ;;
	    to_csv | login | get | post | mint | update | push | fq | anvl | to_anvl ) # http requests
	      $cmd "$@";
	      ;;
      declare ) # informational requests
        _${cmd} "$@";
        ;;
	    OPTIONS )	# http requests
	      $cmd $@;
	      ;;
	    *)
	      echo  "$cmd not found";
	  ;;
    esac
}


function log() {
  (>&2 echo LOG: $@)
}

function err() {
  local n=1;
  if [[ $1 = '--quiet' ]] ; then
    n=$2;
  else
    n=$1
    shift
    (>&2 echo err: $@)
  fi
  exit $n;
}

function encode() {
  # urlencode <string>
  old_lc_collate=$LC_COLLATE
  LC_COLLATE=C

  local length="${#1}"
  for (( i = 0; i < length; i++ )); do
    local c="${1:i:1}"
    case $c in
      [%:$'\n'$'\r'] ) printf '%%%02X' "'$c" ;;
      * ) printf "$c" ;;
# THis is URL encoding
#      [a-zA-Z0-9.~_-]) printf "$c" ;;   # This is URL encoding
#      *) printf '%%%02X' "'$c" ;;
esac
done

  LC_COLLATE=$old_lc_collate
}

function decode() {
  # urldecode <string>

  local url_encoded="${1//+/ }"
  printf '%b' "${url_encoded//%/\\x}"
}

# There are a number of ways to make the ark:
# 1: Fully qualified ark:/?????/???.* => return ark
#
function parse_base() {
  if [[ ${BASE[in]} =~ ^(ark:/)?([0-9][0-9][0-9][0-9][0-9]/)([a-z]*[0-9])$ ]]; then
    BASE[scheme]=${BASH_REMATCH[1]};
    BASE[naan]=${BASH_REMATCH[2]};
    BASE[shoulder]=${BASH_REMATCH[3]};
    BASE[base]=${BASE[scheme]}${BASE[naan]}${BASE[shoulder]}
  else
    log "--base=${BASE[in]} invalid base"
    exit 1
  fi
}

function fq() {
  local v
  local blade
  if [[ $1 =~ ^((ark:/)([0-9][0-9][0-9][0-9][0-9]/)([a-z]+[0-9]))?([a-z]+[0-9])([a-z,0-9]*)([a-z,0-9])(/.*)?$ ]]; then
#    log MATCH $(declare -p BASH_REMATCH)
    v=${BASH_REMATCH[2]};
    ARK[scheme]=${v:-${BASE[scheme]}}
    ARK[scheme]=${BASE[scheme]}
    v=${BASH_REMATCH[3]};
    ARK[naan]=${v:-${BASE[naan]}}

    if [[ -n ${BASH_REMATCH[4]} ]]; then
      ARK[shoulder]=${BASH_REMATCH[4]};
      ARK[blade]=${BASH_REMATCH[5]}${BASH_REMATCH[6]}
    elif [[ ${BASH_REMATCH[5]} == ${BASE[shoulder]} ]]; then
      ARK[shoulder]=${BASE[shoulder]};
      ARK[blade]=${BASH_REMATCH[6]};
    else
      ARK[shoulder]=${BASE[shoulder]};
      ARK[blade]=${BASH_REMATCH[5]}${BASH_REMATCH[6]}
    fi

    ARK[tip]=${BASH_REMATCH[7]};
    ARK[extension]=${BASH_REMATCH[8]};

    ARK[fq]=${ARK[scheme]}${ARK[naan]}${ARK[shoulder]}${ARK[blade]}${ARK[tip]}
    echo ${ARK[fq]}
  else
    log ARK: $1 invalid
    exit 1;
  fi
}

function _http () {
  local stdinp=
  local http="http --check-status --ssl=${EZID[http_ssl]} --session=${EZID[http_session]} --print=${EZID[http_print]}"
  if [[ $1 == '-n' || -n ${EZID[noop]} ]]; then
    [[ $1 == '-n' ]] && shift
    if [[ ! -t 0 ]]; then
      IFS='' read -r -d '' stdinp;
      log "$http $@ <<<$(printf "%q" "$stdinp")"
    else
      log "$http $@"
    fi
  else
    if [[ ! -t 0 ]]; then
      IFS='' read -r -d '' stdinp;
      $http $@  <<<"$stdinp"
    else
      $http $@
    fi
  fi
}

function to_csv() {
  local csv=$1;
  if [[ $csv =~ [,\"$'\n'] ]]; then
    csv=$(sed -e 's/"/""/g' <<<$1)
    echo "\"$csv\""
  else
    echo $csv
  fi
}

# Direct HTTP Requests
function get () {
  local opts=`getopt -o c:hA --long csv:,header,array -n 'ezid get' -- "$@"`
  if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

  eval set -- "$opts"

  local header
  local csv=''
  local array=''
  while true; do
	  case $1 in
      -A | --array ) array='-A'; shift;;
      -c | --csv ) csv="$2"; shift 2;;
      -h | --header )
        header=1;
        shift;;
	    -- ) shift; break;;
	    *) shift; break;
    esac
  done

  local i
  local arr;
  local header_str
  if [[ -n "$csv" && -n "$header" ]]; then
    echo ${csv//:/,}
  fi

  [[ -n $csv ]] && csv="--csv=$csv"
  for i in $@; do
    if [[ -z $csv && -z $array ]]; then
      _http GET https://ezid.cdlib.org/id/$(fq $i)
    else
      local resp=$(_http --print=b GET https://ezid.cdlib.org/id/$(fq $i))
      anvl $csv $array --ark="$i" <<<$resp;
    fi
  done
}

function OPTIONS () {
    _http OPTIONS $(url)
}

function HEAD () {
    _http HEAD $(url)
}

: <<=cut
=pod

=head 2 Declare

The declare command will print a bash style, declare statement for each passed ARK.

=cut

function _declare () {
  for i in $@; do
    log D $i;
    fq_ark $i > /dev/null;
    declare -p ARK
  done
}


: <<=cut
=pod

=head1 AUTHOR

Quinn Hart <qjhart@ucdavis.edu>

=cut


#MAIN
# global Variables
declare -A BASE=([in]='ark:/99999/fk4');
declare -A ARK;
declare -A POST=([_status]='reserved');
declare -A EZID=([noop]=''
                 [http_ssl]="tls1.2"
                 [http_print]="hb"
                 [http_session]="ezid");


while true; do
	case $1 in
	  -*) OPTS=($1); shift ;;
	  -- ) shift; break;;
	  *) break;
	esac
done

function init() {
    local opts=`getopt -o n --long session:,base:,print:,http_print:,http_session: -n 'ezid' -- "$@"`
    if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

    eval set -- "$opts"

    while true; do
	    case $1 in
	      --session | --http_session) EZID[http_session]=$2;  shift 2;;
	      --base) BASE[in]=$2;  shift 2;;
	      -n | --dry-run) EZID[noop]=1; shift ;;
	      --print | --http_print) EZID[http_print]=$2; shift 2;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    parse_base;
}

init $OPTS
main.cmd "$@"

exit 0;
