#! /bin/bash

# program at end of file. search #MAIN
function to_anvl() {
  eval "declare -A anvl="${1#*=}
  for n in ${!anvl[@]}; do
    echo $(encode "$n"): $(encode "${anvl[$n]}")
  done
}

function anvl() {
  declare -A anvl
  local cont='^[ \t]+(.*)';
  local nv='^([^:]+)[ \t]*:[ \t]*(.*)$'
  local n
  local v
  while IFS='' read -r line || [[ -n "$line" ]] ; do
    if [[ $line =~ ^# ]]; then
      true
    elif [[ $line =~ $cont ]]; then
      line=${BASH_REMATCH[1]}
      if [[ -n $n ]]; then
        v+=" $line";
      else
        err 1 'Bad continuation: $line'
      fi
    elif [[ $line =~ $nv ]]; then
      if [[ -n $n ]]; then
        anvl[$n]=$v;
        n=''
      fi
      n=${BASH_REMATCH[1]};
      v=${BASH_REMATCH[2]};
    else
      err 1 "unknown $line"
    fi
  done

  if [[ -n $n ]]; then
    anvl[$n]=$(decode $v);
    n=''
  fi
  declare -p anvl
}

function mint() {
  log MINT "$@"
    local opts=`getopt -o p:w: --long proxy:,who:,what:,when:,print: -n 'ezid mint' -- "$@"`
    if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

    eval set -- "$opts"

    local proxy=

    while true; do
	    case $1 in
        --proxy ) proxy=$2; shift 2;;
        # Metadata items
        --who ) POST[erc.who]=$2; shift 2;;
        --what ) POST[erc.what]=$2; shift 2;;
        --when ) POST[erc.when]=$2; shift 2;;
        --status ) POST[_status]=$2; shift 2;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done
    to_anvl "$(declare -p POST)"
}

: <<=cut
=pod

=head1  NAME

  ezid - Get, Add and Update ARKS via the EZID api

=head1 USAGE

  ark [-S|--session=I<httpie session>] [-b|--base=I<base>] \
  [--who=I<who>] [--what=I<what>] [--when=I<when>] \
  [--status=I<reserved|public>]
	[-n|--dry-run] [-p|--print] \
	I<cmd> [cmd-options]

	where <cmd> = get|patch|put

=cut

: <<=cut

=pod

=head1 OPTIONS

=over 4

=item B<-S|--session=I<httpie_session>>

Set the HTTP session variable. This allows you to maintain multiple
authentication setups for your EZID, so that you can go back and forth between
users.

=item B<-s |--base=I<base>>
Set the base that you want to use.  The base is a combination of the scheme,NAAN, and shoulder
components of the identifier. The Default base is the EZID ark testing shoulder B<ark:/99999/fk4>.
This is a safe place to do your testing.

=item B<--who=I<who>>
Metadata, who

=item B<--what=I<what>>
Metadata, what

=item B<--when=I<when>>
Metadata, when

=item B<-n|--dry-run>
Show what you would do do not really do it

=item B<-p|--print>
Adjust httpie --print= argument

=back
=cut

function main.cmd () {
    cmd=$1
    shift;
    log CMD $1

    case $cmd in
      put )
        create "$@"
        ;;
      post )
        mint "$@"
        ;;
	    get | post | mint | push | fq | anvl | to_anvl ) # http requests
	      $cmd "$@";
	      ;;
      declare ) # informational requests
        _${cmd} "$@";
        ;;
	    OPTIONS )	# http requests
	      $cmd $@;
	      ;;
	    *)
	      echo  "$cmd not found";
	  ;;
    esac
}


function log() {
  (>&2 echo LOG: $@)
}

function err() {
  local n=1;
  if [[ $1 = '--quiet' ]] ; then
    n=$2;
  else
    n=$1
    shift
    (>&2 echo err: $@)
  fi
  exit $n;
}

function encode() {
  # urlencode <string>
  old_lc_collate=$LC_COLLATE
  LC_COLLATE=C

  local length="${#1}"
  for (( i = 0; i < length; i++ )); do
    local c="${1:i:1}"
    case $c in
#      [%:] ) printf '%%%02X' "'$c" ;;
      [%:$'\n'$'\r'] ) printf '%%%02X' "'$c" ;;
      * ) printf "$c" ;;
# THis is URL encoding
#      [a-zA-Z0-9.~_-]) printf "$c" ;;   # This is URL encoding
#      *) printf '%%%02X' "'$c" ;;
esac
done

  LC_COLLATE=$old_lc_collate
}

function decode() {
  # urldecode <string>

  local url_encoded="${1//+/ }"
  printf '%b' "${url_encoded//%/\\x}"
}

# There are a number of ways to make the ark:
# 1: Fully qualified ark:/?????/???.* => return ark
#
function parse_base() {
  if [[ ${BASE[in]} =~ ^(ark:/)?([0-9][0-9][0-9][0-9][0-9]/)([a-z]*[0-9])$ ]]; then
    BASE[scheme]=${BASH_REMATCH[1]};
    BASE[naan]=${BASH_REMATCH[2]};
    BASE[shoulder]=${BASH_REMATCH[3]};
    BASE[base]=${BASE[scheme]}${BASE[naan]}${BASE[shoulder]}
  else
    log "--base=${BASE[in]} invalid base"
    exit 1
  fi
}

function fq() {
  local v
  local blade
  if [[ $1 =~ ^((ark:/)?([0-9][0-9][0-9][0-9][0-9]/))?([a-z]*[0-9])?([a-z,0-9]*)([a-z,0-9])(/.*)?$ ]]; then
    log MATCH $(declare -p BASH_REMATCH)
    v=${BASH_REMATCH[2]};
    ARK[scheme]=${v:-${BASE[scheme]}}
    ARK[scheme]=${BASE[scheme]}
    v=${BASH_REMATCH[3]};
    ARK[naan]=${v:-${BASE[naan]}}

    v=${BASH_REMATCH[4]};
    if [[ -n ${BASH_REMATCH[3]} || -n $v || $v == ${BASE[shoulder]}  ]]; then
      ARK[shoulder]=${v};
      ARK[blade]=${BASH_REMATCH[5]}
    else
      ARK[shoulder]=${BASE[shoulder]};
      ARK[blade]=${v}${BASH_REMATCH[5]};
    fi
    ARK[tip]=${BASH_REMATCH[6]};
    ARK[extension]=${BASH_REMATCH[7]};

    ARK[fq]=${ARK[scheme]}${ARK[naan]}${ARK[shoulder]}${ARK[blade]}${ARK[tip]}
    echo ${ARK[fq]}
  else
    log ARK: $1 invalid
    exit 1;
  fi
}

function _http () {
  local stdinp=
  local http="http --ssl=${INF4[http_ssl]} --session=${INF4[http_session]}"
  if [[ $1 == '-n' || -n ${INF4[noop]} ]]; then
    [[ $1 == '-n' ]] && shift
    if [[ ! -t 0 ]]; then
      IFS='' read -r -d '' stdinp;
      log "$http $@ <<<'$stdinp'"
    else
      log "$http $@"
    fi
  else
    log $http $@
    $http $@
  fi
}

# Direct HTTP Requests
function get () {
  for i in $@; do
    _http GET https://ezid.cdlib.org/id/$(fq $i)
  done
}

function OPTIONS () {
    _http OPTIONS $(url)
}

function HEAD () {
    _http HEAD $(url)
}

: <<=cut
=pod

=head 2 Declare

The declare command will print a bash style, declare statement for each passed ARK.

=cut

function _declare () {
  for i in $@; do
    log D $i;
    fq_ark $i > /dev/null;
    declare -p ARK
  done
}


: <<=cut
=pod

=head1 AUTHOR

Quinn Hart <qjhart@ucdavis.edu>

=cut


#MAIN
# global Variables
declare -A BASE=([in]='ark:/99999/fk4');
declare -A ARK
declare -A POST=([_status]='reserved');
declare -A EZID=([noop]='');
declare -A HTTP=([ssl]="tls1.2"
                 [print]="hb");

declare CMD

while true; do
	case $1 in
	  -*) OPTS=($1); shift ;;
	  -- ) shift; break;;
	  *) break;
	esac
done

function init() {
    local opts=`getopt -o n --long session:,base:,proxy:,who:,what:,when:,print: -n 'ezid' -- "$@"`
    if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

    eval set -- "$opts"

    while true; do
	    case $1 in
	      --session) HTTP[session]=$2;  shift 2;;
	      --base) BASE[in]=$2;  shift 2;;
	      -n | --dry-run) EZID[noop]=1; shift ;;
	      --print) HTTP[print]=$2; shift 2;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    parse_base;
}

init $OPTS
main.cmd "$@"

exit 0;
