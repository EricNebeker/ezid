#! /bin/bash

: <<=cut
=pod

=head1  NAME

ezid - Get, Add and Update ARKS via the EZID api

=head1 SYNOPSIS

  ezid [-S|--session=<httpie session>] [-b|--base=<base>] \
  [-n|--dry-run] [-p|--print] [-h|--help]\
  <command> [<args>]

  where <command> is one of login, get, post|mint, put|create, update, fq, anvl, to_anvl

=head2 EXAMPLES

ezid B<get> [--array] [--csv=I<columns>] [--header] ARK(s)

=head1 DESCRIPTION

Ezid is a script that simplifies the retrieval, creation and update of ezid
ARKS. Ezid uses as set of functions to communicate with the ezid services. Ezid
uses a few other tools to perform the functions. In particular, ezid uses
L<httpie|https://httpie.org/> for its http communcation. This allows users to
combine ezid with other httpie requests when required. The man pages are also
created from the PERL POD commands; pod2usage and pod2text.

A good review of the organization of the ark: can be found in the L<ID
Concepts|https://ezid.cdlib.org/learn/id_concepts> description.

=head1 OPTIONS

=over 4

=item B<-S|--session|--http_session=I<http_session>>

Set the HTTPIE session variable. This allows you to maintain multiple
authentication setups for your EZID, so that you can go back and forth between
users. This is equivalent to the L<httpie|https://httpie.org/> session variable,
and are shared with that command. Sessions primarily keep the basic
authentication parameters saved.  By default the B<ezid> session is used.

=item B<-s |--base=I<base>>

Set the base that you want to use. The base is a combination of the scheme,NAAN,
and shoulder components of the identifier. The default base is the EZID ark
testing shoulder B<ark:/99999/fk4>. This is a safe place to do your testing. If
you are using complete arks in your commands, this is not required, but if you
are using shorthands, for example only using the blades of the arks, then the
fully qualified arks are created from this base.

=item B<-n|--dry-run>

Show what you would do do not really do it. Because some commands require
multiple access to the server, this command does not always work properly

=item B<--print|http_print>
Adjust httpie I<--print=> argument.  By default only the response body I<--print=b> is shown.

=item B<-h|--help>

Shows the manpage for the program

=back

=cut

function init() {
    local opts=`getopt -o nh --long session:,base:,print:,http_print:,http_session:,help -n 'ezid' -- "$@"`
    if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

    eval set -- "$opts"

    while true; do
	    case $1 in
	      --session | --http_session) EZID[http_session]=$2;  shift 2;;
	      --base) BASE[in]=$2;  shift 2;;
	      -n | --dry-run) EZID[noop]=1; shift ;;
	      --print | --http_print) EZID[http_print]=$2; shift 2;;
        -h | --help ) exec pod2text $0;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    parse_base;
}

: <<=cut
=pod

=head1 EZID COMMANDS

There are a number of ezid commands that are used in manipulating the ARKS.

=over 4

=item Retrieval

B<ezid get> retrieves ARKs from the ezid server.  Can output in multiple formats.

=item Additions and Updates

B<ezid login>: Allows users to set and save their login parameters

B<ezid mint>: Mint new Arks

=back

=cut

function main.cmd () {
    cmd=$1
    shift;
    case $cmd in
      put )
        create "$@"
        ;;
      post )
        mint "$@"
        ;;
	    to_csv | login | get | post | mint | update | push | fq | anvl | to_anvl ) # http requests
	      $cmd "$@";
	      ;;
      declare ) # informational requests
        _${cmd} "$@";
        ;;
	    OPTIONS )	# http requests
	      $cmd $@;
	      ;;
	    *)
	      exec pod2usage $0
	  ;;
    esac
}


function log() {
  (>&2 echo LOG: $@)
}

function err() {
  local n=1;
  if [[ $1 = '--quiet' ]] ; then
    n=$2;
  else
    n=$1
    shift
    (>&2 echo err: $@)
  fi
  exit $n;
}

# program at end of file. search #MAIN
function args_to_anvl() {
  local nv='^([^:]+)[ \t]*:[ \t]*(.*)$'
  local n
  local v

  declare -A update

	while [[ -n $1 ]]; do
	  case $1 in
	    -- ) shift; break;;
	    *)
        if [[ $1 =~ $nv ]]; then
          n=${BASH_REMATCH[1]};
          v="${BASH_REMATCH[2]}";
          update[$n]=$(decode "$v");
        else
          log rest $1
          err 1 "Bad Option:" $1
        fi
        shift;;
    esac
  done

  local inp
  if [[ ! -t 0 ]]; then
    inp=$(anvl -A)
    eval "declare -A inp_anvl=${inp#*=}"
    for n in ${!inp_anvl[@]}; do
      update[$n]=${inp_anvl[$n]};
    done
  fi

  local anvl=$(to_anvl "$(declare -p update)")
  echo "$anvl"
}

function to_anvl() {
  eval "declare -A anvl="${1#*=}
  for n in ${!anvl[@]}; do
    echo $(encode "$n"): $(encode "${anvl[$n]}")
  done
}

function anvl() {
  local opts=`getopt -o Ac:a: --long array,csv:,ark: -n 'ezid anvl' -- "$@"`

  if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi
  eval set -- "$opts"

  local array;
  local ark;
  while true; do
	  case $1 in
      -A | --array ) array=1; shift;;
      -a | --ark ) ark=$2; shift;;
      -c | --csv )
        IFS=':' read -r -a csv <<< "$2"
        shift 2;;
	    -- ) shift; break;;
	    *) shift; break;
    esac
  done

  declare -A anvl
  local cont='^[ \t]+(.*)';
  local nv='^([^:]+)[ \t]*:[ \t]*(.*)$'
  local n
  local v
  while IFS='' read -r line || [[ -n "$line" ]] ; do
    if [[ $line =~ ^# ]]; then
      true
    elif [[ $line =~ $cont ]]; then
      line=${BASH_REMATCH[1]}
      if [[ -n $n ]]; then
        v+=" $line";
      else
        err 1 'Bad continuation: $line'
      fi
    elif [[ $line =~ $nv ]]; then
      if [[ -n $n ]]; then
        anvl[$n]=$(decode "$v");
        n=''
      fi
      n=${BASH_REMATCH[1]};
      v="${BASH_REMATCH[2]}";
    else
      err 1 "unknown $line"
    fi
  done

  if [[ -n $n ]]; then
    anvl[$n]=$(decode "$v");
    n=''
  fi

  # Now print the output
  local row
  if [[ -n $array ]]; then
    declare -p anvl
  elif [[ -n $csv ]]; then
    anvl[ark]=$ark;    # Allow specification of bad ark
    local row
    local i
    for i in "${csv[@]}"; do
      row+=,$(to_csv "${anvl[$i]}")
    done
    echo ${row:1}
  fi
}

function mint() {
    local opts=`getopt -o p:c:vA --long proxy:,csv:,array,verify -n 'ezid mint' -- "$@"`
    if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

    eval set -- "$opts"

    local proxy=
    local csv
    local array
    local verify

    while true; do
	    case $1 in
        --proxy ) proxy=$2; shift 2;;
        -c | --csv ) csv="--csv=$2"; shift 2;;
        -v | --verify) verify=1; shift ;;
        -A | --array ) array='--array'; shift ;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    local anvl=$(args_to_anvl "$POST" "$@")
    local resp=$(_http --print=b POST https://ezid.cdlib.org/shoulder/${BASE[base]} Content-Type:text/plain <<<"$anvl")
    resp=$(anvl -A <<<$resp);
    eval "declare -A anvl="${resp#*=}
    if [[ -z ${anvl[success]} ]]; then
      err 1 "No success: $resp"
    fi
    local ark=${anvl[success]}
    if [[ -n $proxy && -n ${ark} ]]; then
      sleep 1;
      update ${ark} _target:${proxy}${ark}
    fi
    if [[ -n $verify || -n $csv || -n $array ]]; then
      get $csv $array $ark
    else
      echo $ark
    fi
}

function update() {
  local opts=`getopt -o c:Av --long csv:,array,verify -n 'ezid update' -- "$@"`
  if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

  eval set -- "$opts"

  local csv
  local array
  local verify

  while true; do
	  case $1 in
      -c | --csv ) csv="--csv=$2"; shift 2;;
      -v | --verify) verify=1; shift ;;
      -A | --array ) array='--array'; shift ;;
	    -- ) shift; break;;
	    *) shift; break;
    esac
  done

  local ark_in=$1
  local ark=https://ezid.cdlib.org/id/$(fq $1)
  [[ $? != 0 ]] && err 1 '$1 is not a valid ark';
  shift

  local anvl=$(args_to_anvl "$@")

  local resp=$(_http --print=b POST $ark Content-Type:text/plain <<<"$anvl")
  local rarr=$(anvl -A <<<$resp);
  eval "declare -A anvl="${rarr#*=}
  if [[ -z ${anvl[success]} ]]; then
    err 1 "No success: $resp"
  fi
  local suc=${anvl[success]}
  if [[ -n $verify || -n $csv || -n $array ]]; then
    get $csv $array $ark_in
  fi
}

function encode() {
  # urlencode <string>
  old_lc_collate=$LC_COLLATE
  LC_COLLATE=C

  local length="${#1}"
  for (( i = 0; i < length; i++ )); do
    local c="${1:i:1}"
    case $c in
      [%:$'\n'$'\r'] ) printf '%%%02X' "'$c" ;;
      * ) printf "$c" ;;
# THis is URL encoding
#      [a-zA-Z0-9.~_-]) printf "$c" ;;   # This is URL encoding
#      *) printf '%%%02X' "'$c" ;;
esac
done

  LC_COLLATE=$old_lc_collate
}

function decode() {
  # urldecode <string>

  local url_encoded="${1//+/ }"
  printf '%b' "${url_encoded//%/\\x}"
}

# There are a number of ways to make the ark:
# 1: Fully qualified ark:/?????/???.* => return ark
#
function parse_base() {
  if [[ ${BASE[in]} =~ ^(ark:/)?([0-9][0-9][0-9][0-9][0-9]/)([a-z]*[0-9])$ ]]; then
    BASE[scheme]=${BASH_REMATCH[1]};
    BASE[naan]=${BASH_REMATCH[2]};
    BASE[shoulder]=${BASH_REMATCH[3]};
    BASE[base]=${BASE[scheme]}${BASE[naan]}${BASE[shoulder]}
  else
    log "--base=${BASE[in]} invalid base"
    exit 1
  fi
}

function fq() {
  local v
  local blade
  if [[ $1 =~ ^((ark:/)([0-9][0-9][0-9][0-9][0-9]/)([a-z]+[0-9]))?([a-z]+[0-9])([a-z,0-9]*)([a-z,0-9])(/.*)?$ ]]; then
#    log MATCH $(declare -p BASH_REMATCH)
    v=${BASH_REMATCH[2]};
    ARK[scheme]=${v:-${BASE[scheme]}}
    ARK[scheme]=${BASE[scheme]}
    v=${BASH_REMATCH[3]};
    ARK[naan]=${v:-${BASE[naan]}}

    if [[ -n ${BASH_REMATCH[4]} ]]; then
      ARK[shoulder]=${BASH_REMATCH[4]};
      ARK[blade]=${BASH_REMATCH[5]}${BASH_REMATCH[6]}
    elif [[ ${BASH_REMATCH[5]} == ${BASE[shoulder]} ]]; then
      ARK[shoulder]=${BASE[shoulder]};
      ARK[blade]=${BASH_REMATCH[6]};
    else
      ARK[shoulder]=${BASE[shoulder]};
      ARK[blade]=${BASH_REMATCH[5]}${BASH_REMATCH[6]}
    fi

    ARK[tip]=${BASH_REMATCH[7]};
    ARK[extension]=${BASH_REMATCH[8]};

    ARK[fq]=${ARK[scheme]}${ARK[naan]}${ARK[shoulder]}${ARK[blade]}${ARK[tip]}
    echo ${ARK[fq]}
  else
    log ARK: $1 invalid
    exit 1;
  fi
}

function _http () {
  local stdinp=
  local http="http --check-status --ssl=${EZID[http_ssl]} --session=${EZID[http_session]} --print=${EZID[http_print]}"
  if [[ $1 == '-n' || -n ${EZID[noop]} ]]; then
    [[ $1 == '-n' ]] && shift
    if [[ ! -t 0 ]]; then
      IFS='' read -r -d '' stdinp;
      log "$http $@ <<<$(printf "%q" "$stdinp")"
    else
      log "$http $@"
    fi
  else
    if [[ ! -t 0 ]]; then
      IFS='' read -r -d '' stdinp;
      $http $@  <<<"$stdinp"
    else
      $http $@
    fi
  fi
}

function to_csv() {
  local csv=$1;
  if [[ $csv =~ [,\"$'\n'] ]]; then
    csv=$(sed -e 's/"/""/g' <<<$1)
    echo "\"$csv\""
  else
    echo $csv
  fi
}

: <<=cut
=head2 GET

ezid I<options> B<get> [--array] [--csv=I<columns>] [--header] ARK(s)

B<ezid get> retrieves existing ARKS from the ezid server, and displays them
either as anvl (default), csv or as a bash array for evaluation. The CSV format
is most suitable for retrieving multiple arks.

=head3 GET OPTIONS

=over 4

=item B<--csv=I<columns>>

You can specify the columns that you would like to retrieve using this
parameter. Somewhat following anvl conventions, the column names are B<:>
delimited. This is a convenient way to create a table from a list of ARKs.

=item B<--header>

When specifing a I<--csv> command, this will include a header on the first row
of the output.

=item B<--array>

This will output a bash style associative array from a given ARK, where each key
of the array is a key of the retrieved ANVL format. these can be C<eval>ed for
use later in a bash script. For example the command C<eval \$(./ezid get --array ark:/87287/d7q30n); echo \${anvl[_target]}>

=back

=cut

function get () {
  local opts=`getopt -o c:hA --long csv:,header,array -n 'ezid get' -- "$@"`
  if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

  eval set -- "$opts"

  local header
  local csv=''
  local array=''
  while true; do
	  case $1 in
      -A | --array ) array='-A'; shift;;
      -c | --csv ) csv="$2"; shift 2;;
      -h | --header )
        header=1;
        shift;;
	    -- ) shift; break;;
	    *) shift; break;
    esac
  done

  local i
  local arr;
  local header_str
  if [[ -n "$csv" && -n "$header" ]]; then
    echo ${csv//:/,}
  fi

  [[ -n $csv ]] && csv="--csv=$csv"
  for i in $@; do
    if [[ -z $csv && -z $array ]]; then
      _http GET https://ezid.cdlib.org/id/$(fq $i)
    else
      local resp=$(_http --print=b GET https://ezid.cdlib.org/id/$(fq $i))
      anvl $csv $array --ark="$i" <<<$resp;
    fi
  done
}

:<<=cut
=head2 LOGIN

  ezid login --auth=USER[:PASS]

B<ezid login> is a simple wrapper around the B<httpie --auth=USER:PASS> command.
This allows users to setup their basic authorization, which is then stored in
the standard httpie session paratmeters. It is possible to maintain multiple users,
via the ezid I<--session> parameter to maintain different users, eg.

  ezid --session=ucd-legacy login --auth=ucd-legacy

After which the session C<ucd-legacy>

=head3 LOGIN OPTIONS

=over 4

=item B<-a|--auth=USER[:PASS]>

You specify the basic authentication for the ezid.cdlib.org server. If you only
specify the USER, then you are prompted for the password.

=back

=cut
function login() {
    local opts=`getopt -o a --long auth: -n 'ezid login' -- "$@"`
    if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

    eval set -- "$opts"

    local auth=

    while true; do
	    case $1 in
        -a | --auth ) auth=$2; shift 2;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done
   _http --auth=${auth} https://ezid.cdlib.org/login
}

function OPTIONS () {
    _http OPTIONS $(url)
}

function HEAD () {
    _http HEAD $(url)
}

: <<=cut
=pod

=head2 ezid I<[options]> declare

The declare command will print a bash style, declare statement for each passed ARK.

=cut

function _declare () {
  for i in $@; do
    log D $i;
    fq_ark $i > /dev/null;
    declare -p ARK
  done
}


: <<=cut
=pod

=head1 AUTHOR

Quinn Hart <qjhart@ucdavis.edu>

=cut


#MAIN
# global Variables
declare -A BASE=([in]='ark:/99999/fk4');
declare -A ARK;
declare POST=$'_status:reserved';
declare -A EZID=([noop]=''
                 [http_ssl]="tls1.2"
                 [http_print]="b"
                 [http_session]="ezid");


while true; do
	case $1 in
	  -*) OPTS=($1); shift ;;
	  -- ) shift; break;;
	  *) break;
	esac
done

init $OPTS
main.cmd "$@"

exit 0;
